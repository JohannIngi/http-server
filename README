
/*
 * Programming Assignment 2 – HTTP server
 *
 * Team:
 * Ármann Pétur Ævarsson [armanna16@ru.is]
 * Jóhann Ingi Bjarnason [johannb16@ru.is]
 *
*/
==============================================================================================
9. (5 points (bonus)) Fairness
One definition of fairness is that all clients that send a request to the server will eventually
receive a reply. Ensure that this is the case for your server and carefully explain why your
server ensures this property.
- Our server ensures fairness because it iterates through all clients that are currently connected. Every client gets to finish all his actions in every iteration. 
If on the other hand or server would e.g. choose a client randomly or always choose the first client that connects, it would not be ensuring fairness.
==============================================================================================
PA2:
Out http server answers requests from one or more clients, up to 10 clients at a time. Answearing their requests with appropriate messages according to the project describtion that we received from our teacher. The server writes a timestamp for each request from clients in a log file that is generated automatically. If a client is inactive on the server for 30 seconds he is timed out and his connection closed. The server responds to requests with various messages, ranging from pure http headers to simple html pages.
Our server was tested using the browsers Microsoft Edge, Google Chrome and Brave.

PA3:


**Descriptions of the functions implemented in this project**
==============================================================================================
void error_handler(char* error_buffer) -> Write out the error message that are sent to this function

int find_next_available_client(pollfd* fds) -> Finding the next available client

void get_time(client_info* client) -> Setting the current date in a time buffer

void write_to_log(client_info* client, server_info* server) -> Writing to a log file in the root directory

void client_handle(server_info* server, client_info* client, int connfd) -> client handler that decides what to do based on the client request; get, post, head or error

void check_content(server_info* server) ->

void set_method(client_info* client) ->

void set_color(client_info* client) ->

void set_keep_alive(client_info* client); ->

void generate_error(server_info* server, client_info* client, char* error_version, char* error_msg, size_t content_len) ->

void send_error() ->

void create_header(server_info* server, client_info* client, size_t content_len) -> Creating a html header to use in all the methods

void handle_get(server_info* server, client_info* client, int connfd) -> Creating a html body for GET requests 

void handle_post(server_info* server, client_info* client, int connfd, int index) -> Creating a html body for POST requests 

void setup_multiple_clients(server_info* server) -> Setting up multiple clients connections

void add_new_client(server_info* server, client_info* clients) -> Adding new clients to the server

void check_for_timeouts(client_info* clients, server_info* server) -> If clients time out then close connection

void run_server(server_info* server, client_info* clients) -> Running the server loop and calling necessary functions

void startup_server(server_info* server, const char* port) -> Starting up the server, binding and listening to appropriate port
void parse(server_info* server, client_info* client, int connfd)




void parse_URL(server_info* server, client_info* client, int connfd, char** first_line)
void add_queries(gpointer key, gpointer val, gpointer data)
void parse_query(client_info* client, char** query)

void check_content(server_info* server)
void init_SSL()